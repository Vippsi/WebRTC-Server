<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Roku</title>
    <style>
      body {
        margin: 0;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
      }
      #v {
        width: 1280px;
        height: 720px;
        object-fit: contain;
      }
      #log {
        display: none;
      }
    </style>
  </head>

  <body>
    <video id="v" autoplay muted playsinline></video>
    <pre id="log"></pre>

    <script type="module">
      import { log } from '/src/utils.ts';
      import { makePC as originalMakePC, addIceToPC } from '/src/webrtc.ts';
      import { createWebSocket } from '/src/websocket.ts';
      import { setupKeyboardControl } from '/src/control.ts';

      const wsUrl =
        (location.protocol === 'https:' ? 'wss://' : 'ws://') +
        location.host +
        '/ws';

      let pc = /** @type {RTCPeerConnection | null} */ (null);
      let remoteDescriptionSet = false;
      let subscriberId = /** @type {string | undefined} */ (undefined);
      /** @type {unknown[]} */
      const pendingCandidates = [];

      function getPC() {
        return pc;
      }
      function getRemoteDescriptionSet() {
        return remoteDescriptionSet;
      }
      function getSubscriberId() {
        return subscriberId;
      }
      function setSubscriberId(id) {
        subscriberId = id;
        window.subscriberId = id;
      }

      function addPendingCandidate(candidate) {
        pendingCandidates.push(candidate);
      }

      async function drainPendingCandidates() {
        if (!pc || !remoteDescriptionSet) return;
        while (pendingCandidates.length) {
          const c = pendingCandidates.shift();
          await addIceToPC(pc, c);
        }
      }

      // Override makePC to include subscriberId in candidate messages
      function makePC(socket) {
        const pc = originalMakePC(socket);
        const originalOnIceCandidate = pc.onicecandidate;
        pc.onicecandidate = (ev) => {
          if (ev.candidate) {
            socket.send(
              JSON.stringify({
                type: 'candidate',
                subscriberId: subscriberId,
                candidate: ev.candidate.toJSON(),
              })
            );
          }
        };
        return pc;
      }

      async function onOffer(sdp) {
        log('got offer');

        // Recreate PC per offer to avoid stale DTLS/transceivers (matches your earlier approach)
        try {
          pc?.close();
        } catch {}
        pc = makePC(ws);
        remoteDescriptionSet = false;

        await pc.setRemoteDescription(sdp);
        remoteDescriptionSet = true;

        await drainPendingCandidates();

        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        const answerMsg = {
          type: 'answer',
          subscriberId: subscriberId,
          sdp: pc.localDescription,
        };
        ws.send(JSON.stringify(answerMsg));
        log('sent answer');
      }

      const ws = createWebSocket(
        wsUrl,
        onOffer,
        drainPendingCandidates,
        getPC,
        getRemoteDescriptionSet,
        addPendingCandidate,
        getSubscriberId,
        setSubscriberId
      );

      // keyboard controls over WS -> signaling -> publisher
      setupKeyboardControl(ws);

      log('viewer ready:', wsUrl);
    </script>
  </body>
</html>
